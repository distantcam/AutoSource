<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /readme.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# AutoSource

[![Build Status](https://img.shields.io/github/actions/workflow/status/distantcam/AutoSource/on-push-run-tests.yml?branch=main)](https://github.com/distantcam/AutoSource/actions/workflows/on-push-run-tests.yml)
[![NuGet Status](https://img.shields.io/nuget/v/AutoSource.svg)](https://www.nuget.org/packages/AutoSource/)

## NuGet packages

https://nuget.org/packages/AutoSource/


## Files included

<details>
<summary><a href="https://github.com/distantcam/AutoSource/blob/main/src/AutoSource/Source/CodeBuilder.cs">CodeBuilder.cs</a></summary>

<!-- snippet: CodeBuilder.cs -->
```cs
using global::Microsoft.CodeAnalysis;
using global::Microsoft.CodeAnalysis.Text;
using global::System.Text;

#nullable enable

namespace AutoSource
{
    internal class CodeBuilder
    {
        private readonly StringBuilder _stringBuilder = new();
        private int _indent = 0;

        public CodeBuilder AppendLine()
        {
            _stringBuilder.AppendLine();
            return this;
        }
        public CodeBuilder AppendLine(string line)
        {
            _stringBuilder.AppendLine(Indent + line);
            return this;
        }

        public void IncreaseIndent() { _indent++; }
        public void DecreaseIndent()
        {
            if (_indent > 0)
            {
                _indent--;
            }
        }

        public CodeBuilder StartBlock()
        {
            AppendLine("{");
            IncreaseIndent();
            return this;
        }
        public CodeBuilder EndBlock()
        {
            DecreaseIndent();
            AppendLine("}");
            return this;
        }

        public char IndentChar { get; set; } = '\t';
        public string Indent => new string(IndentChar, _indent);

        public IDisposable StartPartialType(ITypeSymbol type)
        {
            var ns = type.ContainingNamespace.IsGlobalNamespace
                    ? null
                    : type.ContainingNamespace.ToString();
            var typeKeyword = type.IsRecord
                ? "record"
                : type.IsValueType
                    ? "struct"
                    : "class";

            if (!string.IsNullOrEmpty(ns))
            {
                AppendLine($"namespace {ns}");
                StartBlock();
            }

            var typeStack = new Stack<string>();
            var containingType = type.ContainingType;
            while (containingType is not null)
            {
                var contTypeKeyword = containingType.IsRecord
                    ? "record"
                    : containingType.IsValueType
                        ? "struct"
                        : "class";
                var typeName = containingType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                typeStack.Push(contTypeKeyword + " " + typeName);
                containingType = containingType.ContainingType;
            }

            var nestedCount = typeStack.Count;
            while (typeStack.Count > 0)
            {
                AppendLine($"partial {typeStack.Pop()}");
                StartBlock();
            }

            AppendLine($"partial {typeKeyword} {type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}");
            StartBlock();

            return new CloseBlock(this, 1 + nestedCount + (ns != null ? 1 : 0));
        }

        public static implicit operator SourceText(CodeBuilder codeBuilder)
            => SourceText.From(codeBuilder._stringBuilder.ToString(), Encoding.UTF8);

        private readonly struct CloseBlock : IDisposable
        {
            private readonly CodeBuilder _codeBuilder;
            private readonly int _count;
            public CloseBlock(CodeBuilder codeBuilder, int count) { _codeBuilder = codeBuilder; _count = count; }
            public void Dispose() { for (var i = 0; i < _count; i++) _codeBuilder.EndBlock(); }
        }
    }
}
```
<!-- endSnippet -->

</details>

<details>
<summary><a href="https://github.com/distantcam/AutoSource/blob/main/src/AutoSource/Source/SourceDisplayFormats.cs">SourceDisplayFormats.cs</a></summary>

<!-- snippet: SourceDisplayFormats.cs -->
```cs
using global::Microsoft.CodeAnalysis;

#nullable enable

namespace AutoSource
{
    internal static class SourceDisplayFormats
    {
        public static readonly SymbolDisplayFormat FullyQualifiedParameterFormat = SymbolDisplayFormat.FullyQualifiedFormat
            .WithParameterOptions(
                SymbolDisplayParameterOptions.IncludeName |
                SymbolDisplayParameterOptions.IncludeType |
                SymbolDisplayParameterOptions.IncludeParamsRefOut
            );
    }
}
```
<!-- endSnippet -->

</details>

<details>
<summary><a href="https://github.com/distantcam/AutoSource/blob/main/src/AutoSource/Source/SourceTools.cs">SourceTools.cs</a></summary>

<!-- snippet: SourceTools.cs -->
```cs
using global::Microsoft.CodeAnalysis;
using global::Microsoft.CodeAnalysis.CSharp.Syntax;

#nullable enable

namespace AutoSource
{
    internal static class SourceTools
    {
        public static bool IsCorrectAttribute(string attributeName, SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (syntaxNode is not AttributeSyntax attribute) return false;
            var name = attribute.Name switch
            {
                SimpleNameSyntax ins => ins.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                _ => null
            };
            return name == attributeName || name == attributeName + "Attribute";
        }

        public static IMethodSymbol? GetMethodFromAttribute(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;
            if (attributeSyntax.Parent?.Parent is not MethodDeclarationSyntax methodNode) return null;
            if (context.SemanticModel.GetDeclaredSymbol(methodNode) is not IMethodSymbol method) return null;
            return method;
        }

        public static ITypeSymbol? GetTypeFromAttribute(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // "attribute.Parent" is "AttributeListSyntax"
            // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
            TypeDeclarationSyntax? typeNode = attributeSyntax.Parent?.Parent switch
            {
                ClassDeclarationSyntax classDeclarationSyntax => classDeclarationSyntax,
                RecordDeclarationSyntax recordDeclarationSyntax => recordDeclarationSyntax,
                StructDeclarationSyntax structDeclarationSyntax => structDeclarationSyntax,
                _ => null
            };

            if (typeNode == null) return null;
            if (context.SemanticModel.GetDeclaredSymbol(typeNode) is not ITypeSymbol type) return null;
            return type;
        }
    }
}
```
<!-- endSnippet -->

</details>
